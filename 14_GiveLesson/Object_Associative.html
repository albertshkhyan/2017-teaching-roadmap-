<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>associative object js</title>
</head>
<body>
	


	<script>
		//Объекты – это ассоциативные массивы с дополнительными возможностями:
// Օբյեկտները դրանք բանալի բառերի ու արժեքների կոլեկցիա է 
// console.log(window);
//window.console.log()
//window.Array.prototype.pop();

/*

JavaScript -ում համարյա ամեն ինչ օբյեկտա։ ինչի համարյա որովհետև պրիմիտիվ արժեքները օբյեկտներ չեն՝
1․String
2․Numner
3․Boolean
4․undeifned
5․null


Booleans can be objects (if defined with the new keyword)
Numbers can be objects (if defined with the new keyword)
Strings can be objects (if defined with the new keyword)

Maths are always objects
Arrays are always objects
Functions are always objects
Objects are always objects

*/
//Բայց նույնիսկ պրիմիտիվ տիպերը կարան լինեն օբյեկտ, օրինակ՝
// let bool = new Boolean(true);
// console.log("bool", bool);

/*
__proto__: Boolean
		constructor: ƒ Boolean()
		toString: ƒ toString()
		valueOf: ƒ valueOf()
		__proto__: Object

		[[PrimitiveValue]]: false 
		[[PrimitiveValue]]: true

		*/
//Իրականում մեր մեր գրած պրիմիտիվ արժեքների տակ օբյեկտա աշխատում, Օրինակ՝

// let bool2 = Boolean(true);//հին գրլաձը
// let bool2 = true;
// console.log("bool2", bool2);
/*
//Конструктор - строитель, կառուցող
//տվյալ պարագայում կոնստրուկորտը կարելիա պատկերացնել բուլյանը կառուցող մարդու։ 
//Կոնստրուկտորը դա են ֆունկիցան որը որ կանչվումա․․․ ??

bool2.constructor
ƒ Boolean() { [native code] }
*/


















		/* ************* Ինչա օբյեկտը, մեթոդը և հատկությունը իրական կյանքւմ ****************
			/!\ հատկություն - իրեն բնեորշ առանձնահատկություն
			/!\ մեթոդ - այսինքն ֆունկցիոնալ առումով ինչա կարում անի։
			Օրինակ մեքենան օբյեկտա 
				Մեքենան ունի հատկություններ և մեթոդներ։
					Ինչ հատկություններ ունի, Օրինակ՝
					# ԲՈԼՈՐ ՄԵՔԵՆԱՆԵՐԸ ՈՒՆԵՆ ՀԱՏԿՈՒԹՅՈՒՆ, ԲԱՅՑ ՏԱՐԲԵՐ ԱՐԺԵՔՆԵՐ
						քաշ = '400kg',
						գույն = 'կարմիր',
						անուն = 'Bmw',
						մոդել = 'm5'

					Ինչ մեթոդներ ունի մեքենան, Օրինակ՝
					# ԲՈԼՈՐ ՄԵՔԵՆԱՆԵՐԸ ՈՒՆԵՆ ՆՈՒՅՆ ՄԵԹՈԴՆԵՐԸ ԲԱՅՑ ԿԱՏԱՐՎՈՒՄ ԵՆ ՏԱՐԲԵՐ ԺԱՄԱՆԱԿՆԵՐՈՒՄ
						խոդիա_ընկնում ։ ավտո․խոդիԷԸնկնում(),
						քշվումա ։ ավտո․քշվումա(),
						կանգնումա ։ ավտո․կանգնումա(),
						և այլն․․․
						

						*/


						/*+++++ Օբյեկտները, որպես ասոցացվող անգվածներ +++++*/

/*		մենք արդեն զանգվածներից կհիշենք, որ զ/ծ-ը դա ենա երբ մի փոփոխականին մի քանի որժեք ենք վերագրում։
Զանգվածը կարելիա պատկերացնել մի հատ յաշիկ, որտեղ լցրածը լիքը բաներ։ Եթե ուզենանք ետ յաշիկի մեջից ինչ-որ բան քտնենք դժվար կլինի, ահագին ժամանակ կպահնջվի որ մեր ուզածը գտնենք։

---------Իսկ օբյեկտը ---------
		//# Ասոցացվող օբյեկտը դա մի հա կառուցվածքա որը ավելի լայն հանարավորույուններա տալիս քան զանգվածը, 

 կարելիա սենց պատկերացնել մի հատ շկաֆ, որի մեջ կա դարակներ ու աեմն մի դարակի վրա գրածա իրա պարունակության անունը,(դարակը բանալիով բացում ենք) օրինակ՝
 	գրիչների դարակ ։ կարմիր գրիչ, սև գրիչ, դեղին գրիչ,
 	անունների դարակ ։ Նարեկ, Վահագ, Հայկո, Հոսո։
 	ազգանունների դարակ ։ Ներսիսյան ժ, Կրապետյան և այլն

 #################
 Պատկերացրեք ետ դարակները փագ են ու բացելու համար բանալիա պետք, այինքն դարակը բացում ու վեկալում ենք են արժեքը որը մեզ պետքա։
 #################
 */
// Գրելաձևը - Syntax


// Օբյեկտ ստեղծելու կա 2 ձև

//////////////// 1 ձև
// let obj = new Object();//դատարկ Օբյեկտ իր proto__ -ով։
// Եթե ուզում ենք ինչ-որ բառի ամեն տառը պահվի դարակի մեջ կարելիա իրան սենց գրել՝
	// let obj = new Object('red'); // String > 0: "r" 1: "e" 2: "d" -> ես տարբերակում բանալիները թվեր են, եթե ուզում ենք մեր սեփական բանլիները ստեղծենք


// -> Բայց եթե ուզում ենք դարակի մեջ պահենք, այսինքն բանալի բառ  պետքա գրել սենց՝
// 	let objAutoBMW = new Object();
// 	obj.guyn = 'red';
// 	obj.qash = '400kg';
// console.log("objAutoBMW", objAutoBMW);


//////////////// 2 ձև
//# Սովորաբար մարդիկ 2-րդ գրելաձևն են օգտագործում որովհետև ավելի հարմարա
// let objAutoBMW = {
// 	guyn : 'red',
// 	qash : '400kg',
// 	model : 'M5',
// 	marka : 'BMW' // վերջին ստորակետը պարտադիր չի
// } 


/*--------------------------------------------*/
//Ինչպես հանելություն ստանալ հատկությունների հանդեպ
// let objAutoBMW = {
// 	guyn : 'red',
// 	qash : '400kg',
// 	model : 'M5',
// 	marka : 'BMW'
// } 

// alert(objAutoBMW.guyn);//red
// alert(objAutoBMW['guyn']);//red

// alert(objAutoBMW[guyn]);//guyn is not defined - քանի որ guyn - ը փոփոխական է հասկանում դրա համր պետքա իրան չակրետների մեջ պահել


///////////////Ինչպես ստուգել զ/ծ-ի մեջ կա մեր ուզած բանալի  բառը թե ոչ -> Կա 2 ձև հատկության առակյությունը ստուգելու օբյեկտի մեջ/////////////////

// 1 ձև - in operator
// if('marka' in objAutoBMW ) {// marka բանալի բառը կա մեր օբյեկտում
// 	alert(true);
// }

// 2 ձև -> խորհուրդա տրվում in -ով ստուգել
//* Օբյեկտները մեջ ինչ-որ բան չգնելուց հետո error չի տալիս, այլ undefined
// alert(objAutoBMW.marka === undefined);//false
// alert(objAutoBMW.lala === undefined);//true



/////////////// hasOwnProperty() metod and in operator - diffenrece between ///////////////////


// let mard = {
// 	anun : 'Alfonso',
// 	azganun : 'Stepanyan',
// 	tariq : 23,
// } 

// console.log(mard);//__proto__

// console.log(objAutoBMW.hasOwnProperty('qash'));
// console.log('qash' in objAutoBMW);
////// in //////////
//prototype-ի մեջելա նայում
// console.log('hasOwnProperty' in objAutoBMW);//true հատկություն կա

/*
Պատկերացրեք ես mard ապրումա 16-րդ հարգումա, երբ մեքն in operator-ին ասում ենք քթի ես անունով մարդուն, ինքը սկզբում 16 հարգումա նայում չի թտնում իջնումա 15, հետո 14,13 մինրև հասնի 1 հարգ։

Իսկ hasOwnProperty()
	նայումա մենակ 16-րդ հարգում։

	ետ __proto__ ները ետ հարգերն են 
*/











/*--------------------------Ինչպես ջնջել հատկությունները delete operator--------------------------*/
//delete opeator
//delete obj.name.
// let mard = {
// 	tariq : 30,
// 	anun : "Hamlet",
// 	azganun : 'Nalbandyan',
// 	ser : 'arakan',
// 	mazeri_guyn : 'sev',
// 	// 'mazeri guyn' : 'sev'//mazeri guyn: "sev"
// }

// delete mard.mazeri_guyn;//{tariq: 30, anun: "Hamlet", azganun: "Nalbandyan", ser: "arakan"} -> mazeri_guyn բանալի բառը իր արժեքի հետ միասին ջնջվեց։
// console.log("mard", mard);

/*Վերհիշել varible without var*/
// a = 7;
// delete window.a;
// console.log("a", a);//a is not defined


/*----------------------------------------------------------------------------------------*/















/*+++++++++++++++ for in  +++++++++++++++++++*/
//# length հակություն չունի օբյեկտը - սա առաջացնումա խնդիր եթե ինդեքս չունեն մենք չենք կարող ցիկլով հեթով սաղի վրայով անցնել
// 'use strict'

// var obj = {
// Vahag :'3000$',
// Narek : '1200$', 
// Hayko :'1500$',
// Hoso :'2000$'
// };
// console.log(obj.length);//undefined

// # հատուկ ասոցացվող օբյեկտների համար ստեղծել են for in ցիկլը, որ կարանան բոլոր բանալի բառերի վրայով անցնեն

//* show keys
// for(let key in obj) {
// 	alert(key);//Vahag,Narek,Hayko,Hoso
// }
//* velue of keys
// for(let key in obj) {// փոփոխականը նշել որ use strict -ի ժամանակել աշխատաի
// 	alert(obj[key]);//3000$, 1200$, 1500$, 2000$
// 	// alert(obj.key);// պարտադիր պիտի քառակուսի փակագծերի մեջ նշել, եր արժեքը վեկալի
// }

// # Task - ինչպես իմանալ օբյեկտի հատկությունների քանակը։
// let lengthOfObj = 0;
// for(let key in obj) {
// lengthOfObj++;
// }
// alert(lengthOfObj);//length - ը ստացանք 




//# Task (with $) -> Հաշվել ընհանուր աշխատավաչձի գումարը

// var obj = {
// Vahag :'3000$',
// Narek : '1200$', 
// Hayko :'1500$',
// Hoso :'2000$'
// };

// let sum = 0;
// for(let key in obj){
// sum = sum +  parseInt(obj[key])
// }

// console.log("sum", sum);//7700























/*++++++++++++++++++ Օբյեկտների մեթոդներ ++++++++++++++++++*/

//# 
let objAutoBMW = {
	guyn : 'red',
	qash : '400kg',
	model : 'M5',
	marka : 'BMW',
	xodiTal : function() {
		document.write('<img src="../Images/xodi_ynkav_avton.gif">');
	}
} 
objAutoBMW.xodiTal();


//Հատկության մեջ կարելիա պահել function ու ինքը դառնումա մեթոդ։
// let mard = {
// 	anun : 'Alfonso',
// 	azganun : 'Gasparyan',
// 	tariq : '40t',
// 	anunEvAzganun : function () {
// 		return alert(mard.anun + ' ' + mard.azganun);
// 	}

// } 

// mard.anunEvAzganun();// Մեթոդա քանի որ առանց օբյեկտի չի աշխատի, պիտի նշենք որ օբյեկտի մեջից ենք կանչում
// anunEvAzganun();//anunEvAzganun is not defined


























/***********************************************************************************************************/
//Объекты: передача по ссылке

/*
Օբյեկտների և պրիմիտիվ տիպերի գլխավոր  տարբերրուոյունը ենա թե ինչպես են իրանք պահպանվում ու փոխանցվում հղումով։

*/

//////////Копирование по значению
//#Պրիմիտիվ արժեքները ուղղակի copy-են լինում տվյալ փոփոխականի մեջ։ Օրինակ՝
// let pen = 'red pen';
// let pen2 = pen;
// console.log("pen2", pen2);
//#Արդյունքում իրարց ազատ անկախ ֆունկցիաներ եղան, ուղղակի նույն արժեքներվ։


///////////////Копирование по ссылке
//են փոփոխականը, որին վերագրվածա օբյեկտ, ետ փոոխականի մեջ հենց ետ օբյեկտը չի փահվում, այլ են հասցեն որտեղ որ ետ օբյեկտնա, այլ կերպ ասած փոփոխականի մեջ պահվումա ետ օբյեկտի հասցեն ոչ թե հենց օբյեկտը։
// /!\ օբյեկտները պահվում են HEAP-ի մեջ, և բոլոր բարդ տվյալի տեսաները, իսկ  փոփոխականները փոհվում օպերատիվ հիշողության մեջ։	
// /!\ Что такое стек? Это особая область памяти вашего компьютера, в которой хранятся временные переменные, созданные каждой функцией (включая main()функцию).
//Իսկ օբյեկտների copy-ի չեն լինում, փոփոխականի մեջ պահվումա են 


///////#Սկզբանակի փոփոխականի մեջ չի փոխվում
// let pen1 = 'red pen';
// let pen2 = pen1;
// // console.log("pen2", pen2);
// pen2 = 'blue pen';
// console.log(pen2);// blue pen -> ուղակի pen փոփոխականը փոխվեց
// console.log(pen1);//pen1 - ը չփոխվեց

/*--------------------------------------------*/

///////#Սկզբանակի փոփոխականի մեջելա փոխվում
// let pen1 = {pen : 'red pen'};
// let pen2 = pen;//object > pen: "red pen"
// // console.log("pen2", pen2);
// pen2.pen = 'blue';
// console.log(pen2);//{pen: "blue"}
// console.log(pen);//{pen: "blue"}
// /!\  մի օբյեկտի մեջ փոխեցինք մյուսի մեջել փոխվեց։

/*Օրինակ հասցեն 001
մենք փոխում ենք 001-ով օբյեկտի  հասցեն, 
*/

/*
փոփոխականին օբյեկտ վերագրելը կարելիա պատկերացնել սեյֆի հետ, մենք փոփոխականի մեջ սեյֆը չենք պահում այլ սեյֆի բանաին, իսկ երբ ուրօշ փոփոխականի մեջ ենք ուզում պահել մեր օբյեկտը, մենք պահում ենք ետ սեյֆի բանալի cop-ին ոչ թե հենց սեյֆը։

*/
////////////Ինչպես վերացնել վերոհիշյալ խնդիրը
//եթե ուզում են մեր օբյեկտի կլոնը ստեղծենք, օրինակ՝
/*Որ ներսի բանալի բառը փոխելուց հիմնական օրինակի մե չփոխվի
pen1-ը կանչենք ցույցա red pen, իսկ 
pen2-ը կանրչենք տա blue pen 

/////// ինչու ստեղծել կլոնը /////////////
Կարողա մեջ 100 հատ բանալի բառ կա ու ուզում ես մենակ 18 բանալի բառը փոխվի
*/
//Սկզբում ստեղծում են կլոնը
// let pen1 = {pen : 'red pen'};
// let pen2 = {};//սարքւմ են դատարկ օբյեկտ 

// for(let key in pen1) {
// 	pen2[key] = pen1[key];
// }

// // console.log("pen2", pen2);//pen: "red pen"

// pen2.pen = 'blue pen';

// //չփոխվեց հիմնական օրինակի մեջ
// console.log("pen1", pen1);//{pen: "red pen"} 
// console.log("pen2", pen2);//{pen: "blue pen"}








/*+++++++++++++++++++++*/
//միշտ ներկայիս արժեքնա ցույց տալիս, 
var time = {
  year: 2345,
  month: 11,
  day: 10,
  hour: 11,
  minute: 12,
  second: 13,
  microsecond: 123456
}

//Սենցա կատարվում, որովհետև փոփոխականի մեջ հենց օբյեկտի չի պահվում այլ իրա հասցեն։
console.log(time); // (*)
time.microsecond++; // (**)

// console.log(time);
// time.microsecond++;

// console.log(time);
// time.microsecond++;

</script>
</body>
</html>