<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>index</title>
</head>
<body>
	



	<script>


				/*
19.function
arguments
պարամետրական ֆունկցիա
return
expression , decleration

ինքն իրեն կանչող ֆունկցիա
տողային ֆունկցիա (ES6) - arrow function
default value (ES6)

																					ռեկուրսիա
																					scope
																					hoisting
																					closure


																					*/








		///////////////////// default value /////////////////////////////
//default value (սկզբնական,լռելյայն) - նշանակումա եթե մենք մեր պառամետրին արժեք չենք տալիս, ուրեմն թող ետ արժեք չունեցող պառամետրը, запасной արժեք ունենա, 
// function f(p1,p2) {
// 	return p1 * p2;
// }
// alert(f(10,2));

// Օրինակ default value
// function f(p1,p2 = 2) {
// 	return p1 * p2;
// }
// alert(f(10));
// // alert(f(10,3));//30 - Բայց եթե տանք պառամետրին արգումենտ կնդունի մեր տված արժեքը

//#default value js գրելաձևով - Task
// function f(p1,p2) {
// 	if( p2 == undefined){
// 		 p2 = 2;
// 			return p1 * p2;

// 	}
// 	else {
// 		return p2;
// 	}

// }
// alert(f(10));



//default value - ից հետե Ռեկուրսիվ ֆունկցիա




/*--------------------------------Գլոբալ օբյեկտ ---------------------------------------*/
//*js-ը ինչ տեսնալ տեձանելիության տիրույթ ունի
//*ինչա գլոբալ ու լոկալ փոփոխականը
//*scope - տեսանոլության տիրույթ

//փոփոխականներ և ֆունկցիաններ գլոբալ տիրույթում
//Գլոբալ  անվանում են փոփոխականներ ու ֆունկցիաներ, որոնք չենք գտնվում ֆունկցիայի մեջ։
//js-ում բոլոր գլոբալ փոփոխականները ու ֆունկցիաները window օբյեկտի հատկություններ են ։ 
//Օրինակ՝

// var str = 'Hello';
// function foo() {

// }
// console.log('foo' in window);//true
/*Output
window
	str: "Hello"
	foo: f foo()
	*/
//#Task - եթե window - ի մեջ կա ըտնեց հատկություն
// var str = 'hello';
// if('str' in window) {
// 	console.log(true);
// }
// else{
// 	console.log(false);
// }

// function local_tiruyt() {
// 	var str = 'Hello';
// 	function foo() {

// 	}
// }
/*Output
Արդեն Window գլոբալ օբյեկտի մեջ չկա ետ փոփոխականն ու ֆունկցիան չկամ, քանի որ լոկալ տիրույթում են

*/
//# Function Expression in window
// var foo = function () {

// }
//with function expression - output window -> foo: ƒ ()


//######ֆունկցիայիԻնցիլիզացիա 
// * Երբ մենք ստեղծքւմ ենք function declaration, իրանք միանգամից ստեղծվում են աշխատանքի պադրաստ վիճակում, իսկ function expression-ը նախ պետք ֆունկցիան ինցիլիզացիա անի հետո նոր ետ ֆունկցիան վերագրի ետ փոփոխականին։ 
// * Դրա համար մենք չենք կարող function expression-ը վերեվը կանչել։
		// F. E -ի փոփոխականնը undefined է լունիում ենքան ժամանակ միչև տվյալ ֆունկցիան ինցիլիզացիա չանի, Օրինակ՝

		// var foo = function() {
		// 	var str = 'Hello';
		// 	console.log(str);
		// }

//foo == undefined -> true
/*
foo
ƒ () {
			var str = 'Hello';
			console.log(str);
		}
		*/

// javascript - ում if, for, while -ի ձևավոր փակագծերը սիրունության ու հեշտ ընթեռնելի լինելու համարա, ի տարբերություն ֆունկիցայի
// for(var i = 1; i <= 10; ++i)
// 	if( i % 2 ==0)
// 	console.log(i);//working
// var a = 7, b = 4;
// if(a < b)
// a = b;
// b  = 8;
// alert(a + b);

// Ֆունկցիա ստեղշելուց պարտադիր պիտի ձևավոր փակագծերը նշել
// function foo()
// console.log('hello');// Unexpected identifier - անսպասելի անուն foo()


//-------------------- Qustion ??? --------------------
// console.log(a);
// var a = 5;

// var a;
// console.log(a);
// a = 5;

/*----------------------------*/
// console.log(a);

/*---------------------------*/
// console.log( a ); 
// a = 5;
/*---------------------------*/

/*-------------------------------- Scope ---------------------------------------*/

/*
Scope - ը դա function-ների և փոփոխականներ տեսանելիության տիրույթնա, օրինակ՝
	js-ը փոփոխակնների և function-ների հանդեպ հասանելություն ստանումա scope-ի շնորհիվ։
	var a = 5;
		JS - scope a անունով փոփոխական ունես?
 Scope - հա ունեմ։
		JS - դե ուրեմն իրան վերագրի 5 արժեքը։


Գոյություն ունի 2 տեսակի Scope 
 *local scope - in function
 *global scope - ֆունկցիայից դուրս scope
 // /!\ global sope === window

 */

 	// Example of Scope - թե ոնցա հասնելություն ստանում փոփոխականների բացատրել closure - ի մեջ։
 	// var x = 10;

 	function f() {
 		var y = 15;
 		function g() {
 			var z = 25;
 			console.log(x + y + z);//50
 		}
 		g();
 	}

 	f();

 	/*Explanation

1. Սկզբում ինտերպրետատորը տենումաա, որ կանչածա f() ֆունկցիան,
/!\ Սկզբում միչև ֆունկիցան կանչելու արդեն կատարվածա լինում ինցիլիզացիան։
/!\ js-ը մինչև ֆունկցաին կանչելու գիտի թե որ փոփոխականը որտեղա գտնվում, մեր կոդում բոլոր հայտարաված ֆունկցիաներ ու փոփոխականները տանումա պահումա scope-ում մինչև ինչ-որ կոդը կատարելը։

2․ Տենումա g ֆունկցիան կանչածա մտնումա g ֆունցկիայի մեջ․․․

*/



//function -ի մեջ առանց var  հայտարաված փոփոխականները ավտոմատ  դառնում են գլոբալ, ֆունկիցան պիտի պարտադիր կանչվի որ հայտնվի window-ի մեջ
// function myFunction() {
//   // var carName = "Volvo";//local variable
//   var carName = "Volvo";//global variable -> 'varName' in window : true
// }
// myFunction();

// console.log("carName", carName);
// /!\եթե ուզում եք ֆունկցիայի մեջ հայտարարված փոփոխականը լոկալ լինի պետքա պարտադիր var դնել

//#Հարց - ինչ կցուցադրի այս ֆունկցիան
// var str = 'hello';
// function f() {
// 	str = 'world';
// }
// f();
// console.log(str);




/******************* hoisting, and let & const ***********************/

// # ES 6 -ում դուրս են եկել նոր փոփոխականներ հայտարարելու ձևեր։ let && const


////////////////// let difference between var ///////////////////

// #1 2-րդ անագամ նույն անունով փոփոխական չի կարելի հայտարարել։ Օրիանակ՝
// let a = 5;
// let a = 7;//'a' has already been declared

// #2 let - ը ցանկացած բլոկի մեջ լոկալա ի տարբերություն var-ի։ Օրիանակ՝

// var a = 8;//2-րդ անագամ նուն անունով հայտարրարցինք որտեվ a անունով փոփոխական չի գտնում
// if(1) {
// 	let a = 5;
// }
// alert(a);//a is not defined

// #3 let -ը  հասանելիա միայն իրանից հետո, վերեվը իրան չի կարելի կանչել։

// alert(a);//undefined
// var a = 5;

// alert(a);//a is not defined
// let a = 5;

// /!\ Տպավորությունա ստեղծվում որ let-ը թերություններ ունի var -ի համեմատ, բայց իրականում այս տարբերություննրեը առավելություններ են։

// каждый цикл имеет свою переменную i
// for(let i = 0; i<10; i++) { /* … */ }
// for(let i = 0; i<10; i++) { /* … */ }

// alert( i ); // ошибка: глобальной i нет
// /!\ իսկ որ var -ով գրենք ուղղակի նախորդ ցիկլի արժեքը կփոխի , իսկ ետի խնդիրների կհանգեցնի։


// function banak() {
// 	//LexicalEnvironment {krakox : 10}
// // var i
// 	var krakoxner = [];

// 	for ( var i = 0; i < 10; i++) {;
//         var krakox = (function(x) { // լեկալ փոփոխականա պետք
//         	return function() {// որ 9 անգամ չարտածի
//           	alert(x); // выводит свой номер
//           }
//         })(i);
//         krakoxner.push(krakox);
//       }


//       return krakoxner;
//     }
    
// var banak = banak();
// banak[0](); // սաղ 10 համարի տակ 
// banak[5](); // սաղ 10 համարի տակ 



/*-------------- const-----------------*/

// let a = 5;
// a = 7;
// console.log("a", a);//7 -> արժեքը փոխվավ

//իսկ const - ով
//հստաուն փոփոխականի արժեքը չի լինում փոխել
// const a = 5;
// a = 7;
// console.log("a", a);// Assignment to constant variable.


// /!\ var -ից տարբերվումա նույն տարբերություններով, ինչը որ let-ը;
/*
1․ 2-րդ անագամ նույն անունով փոփոխական չի կարելի հայտարարել։
2․ Ցանակցած բլեկի մեջ լոկալա։
3․ Հասանելիա միայն իրանից հետո, վերեվը իրան չի կարելի կանչել։

*/

//1.
// const hastatun = 2019;
// const hastatun = 2018;//Identifier 'hastatun' has already been declared




/*************** hoisting *****************/
//JavaScript -ի դոկումենտացիայի մեջ չկա hoisting հասկացողությունը մարդուկ ես հասկացողությունը հորինել են որ կարանան հեշտ բացատրեն թե ինչա տեղի ունենում ֆունկցիայի ու փոփոխականի հետ միչև կոդի կատարվելը։

//Օրիանակ 1՝

// foo();//միչև ֆունցկիան կանչելու ինքը հիշողության մեջա պահվումա դրա համար վերեվը ըլնումա կանչել, դա hoisting-ի շնորհիվ է։
// function foo() {
// 	alert('hello world');
// }

// Օրիանակ 2՝
// 'use strict'
// num = 3;
// num += 4;
// var num;
// console.log("num", num);//7

//Օրիանակ 3՝
// var x = 1; // Инициализируем x
// console.log(x + y);
// var y = 2;
/*
var x
x = 1; // Инициализируем x
var y;
console.log(x + y); = 2;
y = 2;

*/

//Օրիանակ 4՝ function expression
// foo();//foo is not a function
// var foo = function () {
// alert('hello');
// }
/*
var foo;
foo() - foo փոփոխական կա բայց ֆունկցիա չի
foo = function () {
	alert('hello');
}
*/

// function-y aveli vereva bardzranum
//Օրիանակ 5՝ 
// var a = 1;
// function foo() {
//   a = 10;
//   return;
//   function a() {}
// }
// foo();
// console.log(a);










</script>

</body>
</html>