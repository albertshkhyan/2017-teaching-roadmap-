<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	

	<script>
		//

		/******************************** primitiv vs reference  **********************************/

// /!\ Բարդ տվյալի տեսակին ասում են reference type նաև

////////////////// pass by value or reference? ///////////////////////
//primitiv are passed by value
//object are passed by reference


/*--------- Պրմիտիվ արժեքը փոփոխականին փոխանցվեց , որպես արժեք -----------*/

/*
Գլոբալում չի փոխվում, որովհետև արժեքնը copy-ի է արվում փոփոխականի մեջ։
*/

// let name = 'Consuela';

// function changeName(localName) {
// 	localName = 'Gvadelupe';
// //1

// console.log(name);
// }
// changeName(name);
// //2
// console.log(name);





/*--------------------*/

/*
Մենք լոկալ տիրույթում փոխեցինք գլոբալ տիրույթում գտնվող օբյեկտի հատկությունը, մենք մտածում  ենք որ պրիմիտիվա արժեքների նման գլոբալ տիրույթում չփոխվի արժեքը, բայց չէ օբյեկտի հետ փոփոխություն անելուց հետո կապ չունի լոկալումա թե չե գլոբալումելա փոխվում։
*/

// let nameObject = {//hasce orinak 001
// 	first : 'Consuela'
// }

//1
// console.log(nameObject);//first: "Consuela"

// function changeNameOfObject(obj){
// 	obj.first = 'Gvadelupe'
// }

// changeNameOfObject(nameObject);


// //2
// console.log(nameObject);//{first: "Gvadelupe"}





// Objects: pass by reference js
//Объекты: передача по ссылке

/*
Օբյեկտների և պրիմիտիվ տիպերի գլխավոր  տարբերրուոյունը ենա թե ինչպես են իրանք պահպանվում ու փոխանցվում հղումով։

*/

//////////Копирование по значению
//#Պրիմիտիվ արժեքները ուղղակի copy-են լինում տվյալ փոփոխականի մեջ։ Օրինակ՝
// let pen = 'red pen';
// let pen2 = pen;
// console.log("pen2", pen2);
//#Արդյունքում իրարց ազատ անկախ ֆունկցիաներ եղան, ուղղակի նույն արժեքներվ։


///////////////Копирование по ссылке
//են փոփոխականը, որին վերագրվածա օբյեկտ, ետ փոոխականի մեջ հենց ետ օբյեկտը չի փահվում, այլ են հասցեն որտեղ որ ետ օբյեկտնա, այլ կերպ ասած փոփոխականի մեջ պահվումա ետ օբյեկտի հասցեն ոչ թե հենց օբյեկտը։
// /!\ օբյեկտները պահվում են HEAP-ի մեջ, և բոլոր բարդ տվյալի տեսաները, իսկ  փոփոխականները փոհվում օպերատիվ հիշողության մեջ։	
// /!\ Что такое стек? Это особая область памяти вашего компьютера, в которой хранятся временные переменные, созданные каждой функцией (включая main()функцию).
//Իսկ օբյեկտների copy-ի չեն լինում, փոփոխականի մեջ պահվումա են 


///////#Սկզբանակի փոփոխականի մեջ չի փոխվում
// let pen1 = 'red pen';
// let pen2 = pen1;
// // console.log("pen2", pen2);
// pen2 = 'blue pen';
// console.log(pen2);// blue pen -> ուղակի pen փոփոխականը փոխվեց
// console.log(pen1);//pen1 - ը չփոխվեց

/*--------------------------------------------*/

///////#Սկզբանակի փոփոխականի մեջելա փոխվում
// let pen1 = {pen : 'red pen'};
// let pen2 = pen;//object > pen: "red pen"
// // console.log("pen2", pen2);
// pen2.pen = 'blue';
// console.log(pen2);//{pen: "blue"}
// console.log(pen);//{pen: "blue"}
// /!\  մի օբյեկտի մեջ փոխեցինք մյուսի մեջել փոխվեց։

/*Օրինակ հասցեն 001
մենք փոխում ենք 001-ով օբյեկտի  հասցեն, 
*/

/*
փոփոխականին օբյեկտ վերագրելը կարելիա պատկերացնել սեյֆի հետ, մենք փոփոխականի մեջ սեյֆը չենք պահում այլ սեյֆի բանաին, իսկ երբ ուրօշ փոփոխականի մեջ ենք ուզում պահել մեր օբյեկտը, մենք պահում ենք ետ սեյֆի բանալի cop-ին ոչ թե հենց սեյֆը։

*/









/******************Ինչպես վերացնել վերոհիշյալ խնդիրը******************/
//եթե ուզում են մեր օբյեկտի կլոնը ստեղծենք, օրինակ՝
/*Որ ներսի բանալի բառը փոխելուց հիմնական օրինակի մե չփոխվի
pen1-ը կանչենք ցույցա red pen, իսկ 
pen2-ը կանրչենք տա blue pen 

/////// ինչու ստեղծել կլոնը /////////////
Կարողա մեջ 100 հատ բանալի բառ կա ու ուզում ես մենակ 18 բանալի բառը փոխվի
*/
//Սկզբում ստեղծում են կլոնը
let pen1 = {pen : 'red pen'};
let pen2 = {};//սարքւմ են դատարկ օբյեկտ 

for(let key in pen1) {
	pen2[key] = pen1[key];
}

// console.log("pen2", pen2);//pen: "red pen"

pen2.pen = 'blue pen';

//չփոխվեց հիմնական օրինակի մեջ
console.log("pen1", pen1);//{pen: "red pen"} 
console.log("pen2", pen2);//{pen: "blue pen"}



/***********************************************************************************/












/*+++++++++Օբյեկտը միշտ ներկայիս արժեքնա ցույց տալիս, ++++++++++++*/

// var time = {
//   year: 2345,
//   month: 11,
//   day: 10,
//   hour: 11,
//   minute: 12,
//   second: 13,
//   microsecond: 123456
// }

// //Սենցա կատարվում, որովհետև փոփոխականի մեջ հենց օբյեկտի չի պահվում այլ իրա հասցեն։
// console.log(time); // (*)
// time.microsecond++; // (**)

// console.log(time);
// time.microsecond++;

// console.log(time);
// time.microsecond++;


	</script>
</body>
</html>